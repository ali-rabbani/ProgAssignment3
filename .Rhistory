rankhospital <- function(state, outcome, num = "best"){
## Read outcome data
temp <- read.csv("outcome-of-care-measures.csv", stringsAsFactors = F)
data <- temp[ , c(2, 7, 11, 17, 23)]
colnames(data) <- c("hospital", "state", "heart attack", "heart failure", "pneumonia")
## HOW COULD I DEFINE THE COLCLASSES OF ONLY THESE 3, 4 COLUMNS WITHOUT
## BOTHERING ABOUT THE OTHERS
suppressWarnings(for(i in c(3, 4, 5)){
data[ , i] <- as.numeric(data[, i])
}
)
##checking if there are invalid names
if(is.na(match(state, unique(data$State)))){
stop("invalid state")
}
if(is.na(match(outcome, c("heart attack", "heart failure", "pneumonia")))){
stop("invalid outcome")
}
##Subset by state
data1 <- data[data$State == state, ]
if(num == "best"){
data1[order(data$outcome, data$"hospital"), ][1, 1]}
else if(num == "worst"){
data1[order(-data$outcome, data$"hospital"), ][1, 1]}
else {data1[order(data$outcome, data$"hospital"), ][num, 1]}
##AGAIN! BETTER WAY OF ASSIGNING THESE VALUES
## Finding the value
}
## IS THERE AN EASIER SMARTER WAY OF DOING THIS??
## IS THERE A WAY MY ARGUMENT WAS AUTOMATICALLY TRANSLATED INTO ITS LONG COLNAME?
rankhospital("TX", "heart failure", 4)
rankhospital <- function(state, outcome, num = "best"){
## Read outcome data
temp <- read.csv("outcome-of-care-measures.csv", stringsAsFactors = F)
data <- temp[ , c(2, 7, 11, 17, 23)]
colnames(data) <- c("hospital", "state", "heart attack", "heart failure", "pneumonia")
## HOW COULD I DEFINE THE COLCLASSES OF ONLY THESE 3, 4 COLUMNS WITHOUT
## BOTHERING ABOUT THE OTHERS
suppressWarnings(for(i in c(3, 4, 5)){
data[ , i] <- as.numeric(data[, i])
}
)
##checking if there are invalid names
if(is.na(match(state, unique(data$state)))){
stop("invalid state")
}
if(is.na(match(outcome, c("heart attack", "heart failure", "pneumonia")))){
stop("invalid outcome")
}
##Subset by state
data1 <- data[data$State == state, ]
if(num == "best"){
data1[order(data$outcome, data$"hospital"), ][1, 1]}
else if(num == "worst"){
data1[order(-data$outcome, data$"hospital"), ][1, 1]}
else {data1[order(data$outcome, data$"hospital"), ][num, 1]}
##AGAIN! BETTER WAY OF ASSIGNING THESE VALUES
## Finding the value
}
## IS THERE AN EASIER SMARTER WAY OF DOING THIS??
## IS THERE A WAY MY ARGUMENT WAS AUTOMATICALLY TRANSLATED INTO ITS LONG COLNAME?
rankhospital("TX", "heart failure", 4)
rankhospital <- function(state, outcome, num = "best"){
## Read outcome data
temp <- read.csv("outcome-of-care-measures.csv", stringsAsFactors = F)
data <- temp[ , c(2, 7, 11, 17, 23)]
colnames(data) <- c("hospital", "state", "heart attack", "heart failure", "pneumonia")
## HOW COULD I DEFINE THE COLCLASSES OF ONLY THESE 3, 4 COLUMNS WITHOUT
## BOTHERING ABOUT THE OTHERS
suppressWarnings(for(i in c(3, 4, 5)){
data[ , i] <- as.numeric(data[, i])
}
)
##checking if there are invalid names
if(is.na(match(state, unique(data$state)))){
stop("invalid state")
}
if(is.na(match(outcome, c("heart attack", "heart failure", "pneumonia")))){
stop("invalid outcome")
}
##Subset by state
data1 <- data[data$State == state, ]
if(num == "best"){
data1[order(data$outcome, data$"hospital"), ][1, 1]}
else if(num == "worst"){
data1[order(-data$outcome, data$"hospital"), ][1, 1]}
else {data1[order(data$outcome, data$"hospital"), ][num, 1]}
##AGAIN! BETTER WAY OF ASSIGNING THESE VALUES
## Finding the value
}
## IS THERE AN EASIER SMARTER WAY OF DOING THIS??
## IS THERE A WAY MY ARGUMENT WAS AUTOMATICALLY TRANSLATED INTO ITS LONG COLNAME?
rankhospital("TX", "heart failure", 4)
rankhospital("TX", "heart failure", 1)
temp <- read.csv("outcome-of-care-measures.csv", stringsAsFactors = F)
data <- temp[ , c(2, 7, 11, 17, 23)]
colnames(data) <- c("hospital", "state", "heart attack", "heart failure", "pneumonia")
suppressWarnings(for(i in c(3, 4, 5)){
data[ , i] <- as.numeric(data[, i])
}
)
rm(list = ls())
rankhospital <- function(state, outcome, num = "best"){
## Read outcome data
temp <- read.csv("outcome-of-care-measures.csv", stringsAsFactors = F)
data <- temp[ , c(2, 7, 11, 17, 23)]
colnames(data) <- c("hospital", "state", "heart attack", "heart failure", "pneumonia")
## HOW COULD I DEFINE THE COLCLASSES OF ONLY THESE 3, 4 COLUMNS WITHOUT
## BOTHERING ABOUT THE OTHERS
suppressWarnings(for(i in c(3, 4, 5)){
data[ , i] <- as.numeric(data[, i])
}
)
##checking if there are invalid names
if(is.na(match(state, unique(data$state)))){
stop("invalid state")
}
if(is.na(match(outcome, c("heart attack", "heart failure", "pneumonia")))){
stop("invalid outcome")
}
##Subset by state
data1 <- data[data$State == state, ]
if(num == "best"){
data1[order(data$outcome, data$"hospital"), ][1, 1]}
else if(num == "worst"){
data1[order(-data$outcome, data$"hospital"), ][1, 1]}
else {data1[order(data$outcome, data$"hospital"), ][num, 1]}
##AGAIN! BETTER WAY OF ASSIGNING THESE VALUES
## Finding the value
}
## IS THERE AN EASIER SMARTER WAY OF DOING THIS??
## IS THERE A WAY MY ARGUMENT WAS AUTOMATICALLY TRANSLATED INTO ITS LONG COLNAME?
rankhospital("TX", "heart failure", 4)
rankhospital("TX", "heart failure", 4)
airquality[["Ozone"]]
identical(airquality$Ozone, airquality[["Ozone"]])
rankhospital <- function(state, outcome, num = "best"){
## Read outcome data
temp <- read.csv("outcome-of-care-measures.csv", stringsAsFactors = F)
data <- temp[ , c(2, 7, 11, 17, 23)]
colnames(data) <- c("hospital", "state", "heart attack", "heart failure", "pneumonia")
## HOW COULD I DEFINE THE COLCLASSES OF ONLY THESE 3, 4 COLUMNS WITHOUT
## BOTHERING ABOUT THE OTHERS
suppressWarnings(for(i in c(3, 4, 5)){
data[ , i] <- as.numeric(data[, i])
}
)
##checking if there are invalid names
if(is.na(match(state, unique(data$state)))){
stop("invalid state")
}
if(is.na(match(outcome, c("heart attack", "heart failure", "pneumonia")))){
stop("invalid outcome")
}
##Subset by state
data1 <- data[data$State == state, ]
if(num == "best"){
data1[order(data1$outcome, data1$"hospital"), ][1, 1]}
else if(num == "worst"){
data1[order(-data1$outcome, data1$"hospital"), ][1, 1]}
else {data1[order(data1$outcome, data1$"hospital"), ][num, 1]}
##AGAIN! BETTER WAY OF ASSIGNING THESE VALUES
## Finding the value
}
## IS THERE AN EASIER SMARTER WAY OF DOING THIS??
## IS THERE A WAY MY ARGUMENT WAS AUTOMATICALLY TRANSLATED INTO ITS LONG COLNAME?
rankhospital("TX", "heart failure", 4)
rankhospital <- function(state, outcome, num = "best"){
## Read outcome data
temp <- read.csv("outcome-of-care-measures.csv", stringsAsFactors = F)
data <- temp[ , c(2, 7, 11, 17, 23)]
colnames(data) <- c("hospital", "state", "heart attack", "heart failure", "pneumonia")
## HOW COULD I DEFINE THE COLCLASSES OF ONLY THESE 3, 4 COLUMNS WITHOUT
## BOTHERING ABOUT THE OTHERS
suppressWarnings(for(i in c(3, 4, 5)){
data[ , i] <- as.numeric(data[, i])
}
)
##checking if there are invalid names
if(is.na(match(state, unique(data$state)))){
stop("invalid state")
}
if(is.na(match(outcome, c("heart attack", "heart failure", "pneumonia")))){
stop("invalid outcome")
}
##Subset by state
data1 <- data[data$State == state, ]
if(num == "best"){
data1[order(data1[[outcome]], data1$"hospital"), ][1, 1]}
else if(num == "worst"){
data1[order(-data1[[outcome]], data1$"hospital"), ][1, 1]}
else {data1[order(data1[[outcome]], data1$"hospital"), ][num, 1]}
##AGAIN! BETTER WAY OF ASSIGNING THESE VALUES
## Finding the value
}
## IS THERE AN EASIER SMARTER WAY OF DOING THIS??
## IS THERE A WAY MY ARGUMENT WAS AUTOMATICALLY TRANSLATED INTO ITS LONG COLNAME?
rankhospital("TX", "heart failure", 4)
rankhospital("TX", "heart failure", "best")
temp <- read.csv("outcome-of-care-measures.csv", stringsAsFactors = F)
data <- temp[ , c(2, 7, 11, 17, 23)]
colnames(data) <- c("hospital", "state", "heart attack", "heart failure", "pneumonia")
suppressWarnings(for(i in c(3, 4, 5)){
data[ , i] <- as.numeric(data[, i])
}
)
class(data[ , 3])
rankhospital <- function(state, outcome, num = "best"){
## Read outcome data
temp <- read.csv("outcome-of-care-measures.csv", stringsAsFactors = F)
data <- temp[ , c(2, 7, 11, 17, 23)]
colnames(data) <- c("hospital", "state", "heart attack", "heart failure", "pneumonia")
## HOW COULD I DEFINE THE COLCLASSES OF ONLY THESE 3, 4 COLUMNS WITHOUT
## BOTHERING ABOUT THE OTHERS
suppressWarnings(for(i in c(3, 4, 5)){
data[ , i] <- as.numeric(data[, i])
}
)
##checking if there are invalid names
if(is.na(match(state, unique(data$state)))){
stop("invalid state")
}
if(is.na(match(outcome, c("heart attack", "heart failure", "pneumonia")))){
stop("invalid outcome")
}
##Subset by state
data1 <- data[data$state == state, ]
if(num == "best"){
data1[order(data1[[outcome]], data1$"hospital"), ][1, 1]}
else if(num == "worst"){
data1[order(-data1[[outcome]], data1$"hospital"), ][1, 1]}
else {data1[order(data1[[outcome]], data1$"hospital"), ][num, 1]}
##AGAIN! BETTER WAY OF ASSIGNING THESE VALUES
## Finding the value
}
## IS THERE AN EASIER SMARTER WAY OF DOING THIS??
## IS THERE A WAY MY ARGUMENT WAS AUTOMATICALLY TRANSLATED INTO ITS LONG COLNAME?
rankhospital("TX", "heart failure", 4)
rm(list = ls())
rankhospital <- function(state, outcome, num = "best"){
## Read outcome data
temp <- read.csv("outcome-of-care-measures.csv", stringsAsFactors = F)
data <- temp[ , c(2, 7, 11, 17, 23)]
colnames(data) <- c("hospital", "state", "heart attack", "heart failure", "pneumonia")
## HOW COULD I DEFINE THE COLCLASSES OF ONLY THESE 3, 4 COLUMNS WITHOUT
## BOTHERING ABOUT THE OTHERS
suppressWarnings(for(i in c(3, 4, 5)){
data[ , i] <- as.numeric(data[, i])
}
)
##checking if there are invalid names
if(is.na(match(state, unique(data$state)))){
stop("invalid state")
}
if(is.na(match(outcome, c("heart attack", "heart failure", "pneumonia")))){
stop("invalid outcome")
}
##Subset by state
data1 <- data[data$state == state, ]
if(num == "best"){
data1[order(data1[[outcome]], data1$"hospital"), ][1, 1]}
else if(num == "worst"){
data1[order(-data1[[outcome]], data1$"hospital"), ][1, 1]}
else {data1[order(data1[[outcome]], data1$"hospital"), ][num, 1]}
##AGAIN! BETTER WAY OF ASSIGNING THESE VALUES
## Finding the value
}
## IS THERE AN EASIER SMARTER WAY OF DOING THIS??
## IS THERE A WAY MY ARGUMENT WAS AUTOMATICALLY TRANSLATED INTO ITS LONG COLNAME?
rankhospital("TX", "heart failure", 4)
rankhospital("MD", "heart attack", "worst")
rankhospital("MN", "heart attack", 5000)
rankhospital <- function(state, outcome){
## Read outcome data
temp <- read.csv("outcome-of-care-measures.csv", stringsAsFactors = F)
data <- temp[ , c(2, 7, 11, 17, 23)]
colnames(data) <- c("hospital", "state", "heart attack", "heart failure", "pneumonia")
## HOW COULD I DEFINE THE COLCLASSES OF ONLY THESE 3, 4 COLUMNS WITHOUT
## BOTHERING ABOUT THE OTHERS
suppressWarnings(for(i in c(3, 4, 5)){
data[ , i] <- as.numeric(data[, i])
}
)
##checking if there are invalid names
if(is.na(match(state, unique(data$state)))){
stop("invalid state")
}
if(is.na(match(outcome, c("heart attack", "heart failure", "pneumonia")))){
stop("invalid outcome")
}
##Subset by state
data1 <- data[data$state == state, ]
## Finding the value
data1[order(data1[[outcome]], data1$"hospital"), ][1, 1]
}
## IS THERE AN EASIER SMARTER WAY OF DOING THIS??
## IS THERE A WAY MY ARGUMENT WAS AUTOMATICALLY TRANSLATED INTO ITS LONG COLNAME?
best("MD", "pneumonia")
rankhospital <- function(state, outcome){
## Read outcome data
temp <- read.csv("outcome-of-care-measures.csv", stringsAsFactors = F)
data <- temp[ , c(2, 7, 11, 17, 23)]
colnames(data) <- c("hospital", "state", "heart attack", "heart failure", "pneumonia")
## HOW COULD I DEFINE THE COLCLASSES OF ONLY THESE 3, 4 COLUMNS WITHOUT
## BOTHERING ABOUT THE OTHERS
suppressWarnings(for(i in c(3, 4, 5)){
data[ , i] <- as.numeric(data[, i])
}
)
##checking if there are invalid names
if(is.na(match(state, unique(data$state)))){
stop("invalid state")
}
if(is.na(match(outcome, c("heart attack", "heart failure", "pneumonia")))){
stop("invalid outcome")
}
##Subset by state
data1 <- data[data$state == state, ]
## Finding the value
data1[order(data1[[outcome]], data1$"hospital"), ][1, 1]
}
## IS THERE AN EASIER SMARTER WAY OF DOING THIS??
## IS THERE A WAY MY ARGUMENT WAS AUTOMATICALLY TRANSLATED INTO ITS LONG COLNAME?
best <- function(state, outcome){
## Read outcome data
temp <- read.csv("outcome-of-care-measures.csv", stringsAsFactors = F)
data <- temp[ , c(2, 7, 11, 17, 23)]
colnames(data) <- c("hospital", "state", "heart attack", "heart failure", "pneumonia")
## HOW COULD I DEFINE THE COLCLASSES OF ONLY THESE 3, 4 COLUMNS WITHOUT
## BOTHERING ABOUT THE OTHERS
suppressWarnings(for(i in c(3, 4, 5)){
data[ , i] <- as.numeric(data[, i])
}
)
##checking if there are invalid names
if(is.na(match(state, unique(data$state)))){
stop("invalid state")
}
if(is.na(match(outcome, c("heart attack", "heart failure", "pneumonia")))){
stop("invalid outcome")
}
##Subset by state
data1 <- data[data$state == state, ]
## Finding the value
data1[order(data1[[outcome]], data1$"hospital"), ][1, 1]
}
## IS THERE AN EASIER SMARTER WAY OF DOING THIS??
## IS THERE A WAY MY ARGUMENT WAS AUTOMATICALLY TRANSLATED INTO ITS LONG COLNAME?
best("MD", "pneumonia")
best("MD", "heart attack")
best("TX", "heart failure")
best("TX", "heart attack")
best("BB", "heart attack")
best("NY", "hert attack")
rankhospital <- function(state, outcome, num = "best"){
temp <- read.csv("outcome-of-care-measures.csv", stringsAsFactors = F)
data <- temp[ , c(2, 7, 11, 17, 23)]
colnames(data) <- c("hospital", "state", "heart attack", "heart failure", "pneumonia")
suppressWarnings(for(i in c(3, 4, 5)){
data[ , i] <- as.numeric(data[, i])})
if(is.na(match(state, unique(data$state)))){
stop("invalid state")}
if(is.na(match(outcome, c("heart attack", "heart failure", "pneumonia")))){
stop("invalid outcome")}
data1 <- data[data$state == state, ]
if(num == "best"){
data1[order(data1[[outcome]], data1$"hospital"), ][1, 1]}
else if(num == "worst"){
data1[order(-data1[[outcome]], data1$"hospital"), ][1, 1]}
else {data1[order(data1[[outcome]], data1$"hospital"), ][num, 1]}}
rankhospital("MD", "heart attack", "worst")
?apply
rankall <- function(outcome, num = "best"){
temp <- read.csv("outcome-of-care-measures.csv", stringsAsFactors = F)
data <- temp[ , c(2, 7, 11, 17, 23)]
colnames(data) <- c("hospital", "state", "heart attack", "heart failure", "pneumonia")
suppressWarnings(for(i in c(3, 4, 5)){
data[ , i] <- as.numeric(data[, i])})
if(is.na(match(state, unique(data$state)))){
stop("invalid state")}
if(is.na(match(outcome, c("heart attack", "heart failure", "pneumonia")))){
stop("invalid outcome")}
apply(data, data$states, {if(num == "best"){
data1[order(data1[[outcome]], data1$"hospital"), ][1, 1]}
else if(num == "worst"){
data1[order(-data1[[outcome]], data1$"hospital"), ][1, 1]}
else {data1[order(data1[[outcome]], data1$"hospital"), ][num, 1]}})}
head(rankall("heart attack", 20), 10)
rankall <- function(outcome, num = "best"){
temp <- read.csv("outcome-of-care-measures.csv", stringsAsFactors = F)
data <- temp[ , c(2, 7, 11, 17, 23)]
colnames(data) <- c("hospital", "state", "heart attack", "heart failure", "pneumonia")
suppressWarnings(for(i in c(3, 4, 5)){
data[ , i] <- as.numeric(data[, i])})
if(is.na(match(state, unique(data$state)))){
stop("invalid state")}
if(is.na(match(outcome, c("heart attack", "heart failure", "pneumonia")))){
stop("invalid outcome")}
sapply(tapply(data, data$states),(
if(num == "best"){
data1[order(data1[[outcome]], data1$"hospital"), ][1, 1]}
else if(num == "worst"){
data1[order(-data1[[outcome]], data1$"hospital"), ][1, 1]}
else {data1[order(data1[[outcome]], data1$"hospital"), ][num, 1]}
))
}
head(rankall("heart attack", 20), 10)
rankall <- function(outcome, num = "best"){
temp <- read.csv("outcome-of-care-measures.csv", stringsAsFactors = F)
data <- temp[ , c(2, 7, 11, 17, 23)]
colnames(data) <- c("hospital", "state", "heart attack", "heart failure", "pneumonia")
suppressWarnings(for(i in c(3, 4, 5)){
data[ , i] <- as.numeric(data[, i])})
if(is.na(match(state, unique(data$state)))){
stop("invalid state")}
if(is.na(match(outcome, c("heart attack", "heart failure", "pneumonia")))){
stop("invalid outcome")}
sapply(tapply(data, data$state),(
if(num == "best"){
data1[order(data1[[outcome]], data1$"hospital"), ][1, 1]}
else if(num == "worst"){
data1[order(-data1[[outcome]], data1$"hospital"), ][1, 1]}
else {data1[order(data1[[outcome]], data1$"hospital"), ][num, 1]}
))
}
head(rankall("heart attack", 20), 10)
rankall <- function(outcome, num = "best"){
temp <- read.csv("outcome-of-care-measures.csv", stringsAsFactors = F)
data <- temp[ , c(2, 7, 11, 17, 23)]
colnames(data) <- c("hospital", "state", "heart attack", "heart failure", "pneumonia")
suppressWarnings(for(i in c(3, 4, 5)){
data[ , i] <- as.numeric(data[, i])})
if(is.na(match(outcome, c("heart attack", "heart failure", "pneumonia")))){
stop("invalid outcome")}
sapply(tapply(data, data$state),(
if(num == "best"){
data1[order(data1[[outcome]], data1$"hospital"), ][1, 1]}
else if(num == "worst"){
data1[order(-data1[[outcome]], data1$"hospital"), ][1, 1]}
else {data1[order(data1[[outcome]], data1$"hospital"), ][num, 1]}
))
}
head(rankall("heart attack", 20), 10)
rankall <- function(outcome, num = "best"){
temp <- read.csv("outcome-of-care-measures.csv", stringsAsFactors = F)
data <- temp[ , c(2, 7, 11, 17, 23)]
colnames(data) <- c("hospital", "state", "heart attack", "heart failure", "pneumonia")
suppressWarnings(for(i in c(3, 4, 5)){
data[ , i] <- as.numeric(data[, i])})
if(is.na(match(outcome, c("heart attack", "heart failure", "pneumonia")))){
stop("invalid outcome")}
sapply(tapply(data, data$state),(
if(num == "best"){
data[order(data[[outcome]], data$"hospital"), ][1, 1]}
else if(num == "worst"){
data[order(-data1[[outcome]], data$"hospital"), ][1, 1]}
else {data[order(data1[[outcome]], data$"hospital"), ][num, 1]}
))
}
head(rankall("heart attack", 20), 10)
rankall <- function(outcome, num = "best"){
temp <- read.csv("outcome-of-care-measures.csv", stringsAsFactors = F)
data <- temp[ , c(2, 7, 11, 17, 23)]
colnames(data) <- c("hospital", "state", "heart attack", "heart failure", "pneumonia")
suppressWarnings(for(i in c(3, 4, 5)){
data[ , i] <- as.numeric(data[, i])})
if(is.na(match(outcome, c("heart attack", "heart failure", "pneumonia")))){
stop("invalid outcome")}
sapply(tapply(data, data$state),(
if(num == "best"){
data[order(data[[outcome]], data$"hospital"), ][1, 1]}
else if(num == "worst"){
data[order(-data[[outcome]], data$"hospital"), ][1, 1]}
else {data[order(data[[outcome]], data$"hospital"), ][num, 1]}
))
}
head(rankall("heart attack", 20), 10)
rankall <- function(outcome, num = "best"){
temp <- read.csv("outcome-of-care-measures.csv", stringsAsFactors = F)
data <- temp[ , c(2, 7, 11, 17, 23)]
colnames(data) <- c("hospital", "state", "heart attack", "heart failure", "pneumonia")
suppressWarnings(for(i in c(3, 4, 5)){
data[ , i] <- as.numeric(data[, i])})
if(is.na(match(outcome, c("heart attack", "heart failure", "pneumonia")))){
stop("invalid outcome")}
list <- tapply(data, data$state)
length(list)
}
head(rankall("heart attack", 20), 10)
rankall("heart attack", 20)
rankall <- function(outcome, num = "best"){
temp <- read.csv("outcome-of-care-measures.csv", stringsAsFactors = F)
data <- temp[ , c(2, 7, 11, 17, 23)]
colnames(data) <- c("hospital", "state", "heart attack", "heart failure", "pneumonia")
suppressWarnings(for(i in c(3, 4, 5)){
data[ , i] <- as.numeric(data[, i])})
if(is.na(match(outcome, c("heart attack", "heart failure", "pneumonia")))){
stop("invalid outcome")}
statenames <- unique(data$state)
hospital <- character()
for(i in statenames){
data1 <- data[data$state == i, ]
if(num == "best"){
tempo <- data1[order(data1[[outcome]], data1$"hospital"), ][1, 1]}
else if(num == "worst"){
tempo <- data1[order(-data1[[outcome]], data1$"hospital"), ][1, 1]}
else {tempo <- data1[order(data1[[outcome]], data1$"hospital"), ][num, 1]}
hospital <- c(hospital, tempo)
}
cbind(hospital, statenames)
}
rankall("heart attack", 20)
